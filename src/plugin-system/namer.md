---
layout: layout.njk
eleventyNavigation:
  key: plugin-system-namer
  title: Namer
  order: 6
summary: "Тип плагина: создает путь к выходному файлу для пакета."
---

Именовщики принимают пакет и выводят путь к файлу для этого пакета (результирующий путь должен быть относительно `rootDir`).

```js
import { Namer } from "@parcel/plugin";

export default new Namer({
  async name({ bundle, bundleGraph, logger, options }) {
    if (bundle.filePath != null) {
      // цель указала выходной путь
      return bundle.filePath;
    }

    let name = yourNamingFunction(bundle);
    if (!bundle.isEntry) {
      name += "." + bundle.hashReference;
    }
    return name + "." + bundle.type;
  },
});
```

{% error %}
Вы должны убедиться, что пути к файлам пакета уникальны.
{% enderror %}

У именовщиков есть полная свобода выбора путей к файлам, но они все равно должны следовать этим правилам:

- Верните `bundle.filePath`, если он установлен, чтобы убедиться, что выходной файл, установленный в `package.json#target`, соблюдается.
- Если `bundle.isEntry` истинно, не включайте [хэш в имя файла](#Including-a-hash).

## Переопределение имен для определенных пакетов

В файле [`.parcelrc`](/configuration/plugin-configuration/) можно указать несколько именователей. Если какой-либо плагин `namer` возвращает `null`, запрашивается следующий namer в списке (и так далее).

Это упрощает переопределение имени файла для определенного пакета без копирования существующего (общего) namer.

## Включая хеш

Если вы хотите включить в имя файла хэш, основанный на конечном содержимом пакета, вставьте `bundle.hashReference`. Это непрозрачное значение, которое позже будет заменено фактическим хешем (поскольку на этом этапе нет содержимого пакета для генерации хеша).

{% warning %}
По крайней мере, в именователе по умолчанию хеши также гарантируют, что имена/пути пакетов уникальны (особенно для общих пакетов).
{% endwarning %}

## Соответствующий API

{% include "../../api/namer.html" %}
